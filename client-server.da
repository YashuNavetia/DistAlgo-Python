import sys
import configparser
import logging
import random
   
    

class Master(process):
    def main():
        setup_logfile("./Logs/master_logs.txt")
        #output("Logging master logs to master_logs.txt")
        notify()
        await(0)

    def setup_logfile(filename):
        rootlog = logging.getLogger('')
        filelvl = logging.INFO
        fh = logging.FileHandler(filename)
        formatter = logging.Formatter('[%(asctime)s]%(name)s: %(message)s')
        fh.setFormatter(formatter)
        fh.setLevel(filelvl)
        rootlog._filelvl = filelvl
        rootlog.addHandler(fh)

    def setup(totalServList,totalClientList,timeout):
        self.q = set()
        self.totalServList = list(totalServList)
        #self.myself = master
        self.removeIndex = []
        self.totalClientList = list(totalClientList)
        self.totalTail = []
        self.TIMEOUT = timeout
        self.transfer_reqHead = []
        self.chain_exttail = []

       
        init_tailList(totalServList)

    def init_tailList(totalServList):
        for chainList in totalServList:
          totalTail.append(chainList[len(chainList)-1]) 

    def notify():
      
      while True:
        
        if (await(False)):
          pass
        elif timeout(TIMEOUT):
          
          
          serverCrash = False
          init_tailList(totalServList)

          for bankNo,servList in enumerate(totalServList): 
            if not servList:
              continue
            for i,server in enumerate(servList):   
              if((0,server) in q):
                q.remove((0,server))
              else:
                removeIndex.append(server)
                serverCrash = True
                output("\nMaster:identified crashed server now as: " +str(server) +"from bankNO: " +str(bankNo+1))
          #end of server for loop    
          if (serverCrash):
            for value in removeIndex:
                for servList in totalServList:
                  if value in servList:
                    servList.remove(value)
                    #print("check here.."+str(totalServList))
                    break

            for bankNo,servList in enumerate(totalServList):
              chainLength = len(servList)
              l_head = servList[0]
              l_tail = servList[chainLength - 1]
              if chainLength >1:
                for i,server in enumerate(servList):            
                  #output("STOP under TESTING")
                                  
                  if(server == l_head):
                    prev = None
                    next = servList[i+1]
                    role = 'head'
                    send(('Update',None,next,role), to=server)
                    send((role,server), to=totalClientList[bankNo])
                  elif (server == l_tail):
                    prev = servList[i-1]
                    next = None
                    role = 'tail'
                    send(('Update',prev,None,role), to=server)
                    send((role,server), to=totalClientList[bankNo])
                  else:
                    role = 'replica'+str(i)
                    output(role)
                    prev = servList[i-1]
                    next = servList[i+1]
                    send(('Update',prev,next,role), to=server)

                  #output("\n\tSending req. to update buffer\n")
                  #send(('start updating buffer'), to=head)
            #end of for loop 
            for index,item in enumerate(transfer_reqHead):
              for x in removeIndex:
                if str(x) in str(item):
                  break
                else:
                  del transfer_reqHead[index]
            
            #print("\n\tcheck here1:.."+str(chain_exttail))
            for index,item in enumerate(chain_exttail):
              for x in removeIndex:
                if str(x) in str(item):
                  print("\n\tcheck here2:.."+str(chain_exttail))
                  break
                else:
                  del chain_exttail[index]               
            del removeIndex[:] 
            print("calling pendng req.:"+str(transfer_reqHead))
            pending_req()
          else:pass
            #print("no crash ,value of transfer req head: "+str(transfer_reqHead))
            
          
    # Add in queue for all server pings- "I am Alive"
    def receive(msg=('I am alive'), from_=server):
        #output("\n\tI am alive-server: " +str(server)+"\n")
        q.add((0,server))
       
    def receive(msg=('Client init'), from_=client):pass
        #output("Master: init msg received from client: "+str(client))

    def receive(msg=('chainExtention',bankNo), from_=newTail):
        output("chain Extension msg received from new server"+str(newTail))
        servList = totalServList[bankNo]
        chainLength = len(servList)
        l_tail = servList[chainLength - 1] 
        chain_exttail.append(str(bankNo)+" "+str(newTail)+" "+str(l_tail))
        print("\n\tcheck here0:.."+str(chain_exttail))
        my_sleep(bankNo,newTail)
        
    def my_sleep(bankNo,newTail):

        servList = totalServList[bankNo]
        chainLength = len(servList)
        l_tail = servList[chainLength - 1] 
        #imp todo chk here..... what if l_tail is already crashed wait for master to recover from this.....
        role = 'replica'+str(chainLength -1)
        #output("current tail"+str(l_tail))
        send(('chainUpdate',role,newTail), to=l_tail)

    def receive(msg=('newTail',bankNo),from_=newTail):
        output("chain Extension completes,new tail added:"+str(newTail))
        
        q.add((0,newTail))
        totalServList[bankNo].append(newTail) 
        clientList = totalClientList[int(bankNo)]
        send(('tail',newTail), to=clientList)

    def receive(msg=('sync next',tempList,sendTo,bankNo),from_=server):
        output("sync next received from:" +str(server))
        #output(tempList)
        reqType = tempList[0]
        clientId = str(tempList[1])
        clientList = totalClientList[bankNo]
        for client in clientList:
          if clientId in (str(client)):
            clientId = client
            break       
        bankName = tempList[2]
        clientNumber = tempList[3]
        sequenceNumber = tempList[4]
        accountNumber = tempList[5]
        amount = tempList[6]
        if (reqType == "Transfer from") or (reqType == "Transfer to"):
          destBankNo = tempList[7]
          destAccount = tempList[8]
          print (str(destBankNo))
          print (str(destAccount))
          send((reqType, clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount,destBankNo,destAccount), to=sendTo)
        else:
          send((reqType, clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount,), to=sendTo)
        
    #///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    def receive(msg=('destBank ID',destBankNo,srcBankNo), from_=servTail):
       
        print ("\n\tgot req from bank tail, transfer to another bank head: "+str(destBankNo+1))
        bankList = totalServList[int(destBankNo)]
        destBank = bankList[0]
        transfer_reqHead.append(str(destBankNo)+" "+str(srcBankNo)+" "+str(destBank))
        
        #output("sending destBank head address..." + str(destBank))
        send(('destBank id',destBank), to=servTail)
    
    def pending_req():
        
        for item in transfer_reqHead:
          l = list(item.split())
          destBankNo,srcBankNo = int(l[0]),int(l[1])
          destBankList = totalServList[destBankNo]
          destBank = destBankList[0]
          srcBankList = totalServList[srcBankNo]
          servTail = srcBankList[len(srcBankList)-1]          
          #print(type(servTail)) 
          send(('destBank id',destBank), to=servTail)

        for item in chain_exttail:
          l = list(item.split())
          my_sleep(int(l[0]),int(l[1]))

        del transfer_reqHead[:]
        del chain_exttail[:]

    #///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Server(process):
    #self.next1 = 5
    def setup(role,prev,next,maxReceive,maxSend,startDelay,master,timeout,bankNo):  
        self.bankName = None
        self.clientNumber = -1
        self.sequenceNumber = -1
        self.accountNumber = -1   
        self.amount = 0.0
        self.outcome = None
        self.processedTransactions = {}
        #The below list stores the request IDs that have been processed
        self.processedRequestIDs = list()
        #The below dictionary stores the account numbers and the balance in the account
        self.accountSummary = {}
        self.balance = 0.0   #need to change
        self.maxReceive = maxReceive
        self.maxSend = maxSend
        self.startDelay = startDelay
        self.role = str(role)
        self.master = master
        self.crash = False
        self.prev = prev
        self.next = next
        self.receiveCount = 0
        self.sendCount = 0
        self.reqType = None
        self.clientId = None
        self.Sent = {}
        self.TIMEOUT = timeout
        self.bankNo = bankNo
        self.destAccount = -1
        self.destBankNo = -1
        #self.sleep = True        

        #output("start Server id:" + str(self.id)+ " next id " +str(next))

    def main():  
        
        setup_logfile("./Logs/server_logs.txt")
        #output("Logging server logs to Logs/server_logs.txt")

        while(startDelay):
          if await(False):
            pass
          elif timeout(startDelay):
            startDelay = 0
            send(('chainExtention',bankNo), to=master)
                                  
        while (crash == False):
          #output("inside main, server: "+ str(role) +str(crash))
          if(receiveCount >= maxReceive or sendCount >= maxSend):
            crash = True        
          if(await(False)):
            pass
          elif timeout(TIMEOUT):
            send(('I am alive'), to=master)
            
        #output("Killing server: with crash value" + str(crash))
        await(crash)


       
    def setup_logfile(filename):
        rootlog = logging.getLogger('')
        filelvl = logging.INFO
        fh = logging.FileHandler(filename)
        formatter = logging.Formatter('[%(asctime)s]%(name)s: %(message)s')
        fh.setFormatter(formatter)
        fh.setLevel(filelvl)
        rootlog._filelvl = filelvl
        rootlog.addHandler(fh)

    def receive(msg=('ack',reqID), from_=next):
        if(crash != True):
          Sent[reqID] = True;
          output("sending ack to remove old update: "+ str(reqID) + " from : " +str(role))
          if prev != None:
            send(('ack',reqID), to=prev)


    def sync_next(reqID):
        if(crash != True):
          output("\n inside sync_next:" + reqID+"\n")
          #'Deposit' + str(clientId) + bankName + reqID + str(amount)
            
          for transaction in processedTransactions:
            if reqID in transaction.lower():
              #print(str(transaction))
              tempList = transaction.split("|")
              break;
          sendTo = next
          if(next == None):
            sendTo = self.id
          #output("<<<<<<<check here...........sending to: "+ str(sendTo))
          send(("sync next",tempList,sendTo,bankNo), to=master)
          

    def receive(msg=('Update',prevServ, nextServ,role), from_=master):
        #output("<<<<<<<check here............>>>>>>"+str(prevServ)+ "next: "+str(nextServ))
        if(crash != True):
          if (next != nextServ):
            next = nextServ
            self.role = str(role)
            #output("<<<<<<<check here............>>>>>>"+str(role))
            for reqID in Sent.keys():
              if Sent[reqID] == False:
                sync_next(reqID)
          prev = prevServ
        

                      
   
    def receive(msg=('chainUpdate',newRole,newTail), from_=master):
        if(crash != True):
          role = newRole
          next = newTail
          send(('setup',processedTransactions,processedRequestIDs,accountSummary,Sent),to=newTail)
     

    def receive(msg=('setup',processedTransactions,processedRequestIDs,accountSummary,Sent),from_=prevTail):
        output("i am new tail,informing master")
        if(crash != True):
          role = 'tail'
          next = None
          prev = prevTail
          self.processedTransactions = processedTransactions
          self.processedRequestIDs = processedRequestIDs
          self.accountSummary = accountSummary
          self.Sent = dict(Sent)
          send(('newTail',bankNo),to=master)
                  
    #///////////////////////////////////////////////////////QUERY HANDLING FROM CLIENT////////////////////////////////////////////////////////////////////////

    def receive(msg=('GetBalance', clientId, bankName, clientNumber, sequenceNumber, accountNumber), from_=client):
        #output("\nreq. received for getbalance,my role: "+str(role))
        #output(str(role))
        if role == 'tail':
          #output("\nreq. received for getbalance...\n")
          self.clientId = clientId
          self.bankName = bankName
          self.clientNumber = clientNumber
          self.sequenceNumber = sequenceNumber
          self.accountNumber = accountNumber
          
          receiveCount +=1
          self.reqType = 'GetBalance'
          
          #output("\role: "+str(role)+",receive: "+str(maxReceive))
          if(sendCount >= maxSend or receiveCount >= maxReceive):
            crash = True
            if(sendCount >= maxReceive):
              output("\n\tGet balance:server crashed just after sending total req no:" + str(sendCount))
            else:
              output("\n\tGet balance:server crashed after receiving total req = " + str(receiveCount))
          else:
            transaction = 'GetBalance' + str(clientId)+bankName + str(clientNumber) + str(sequenceNumber) + str(accountNumber)
            #If the same transaction has already been processed, return the same reply
            if transaction in processedTransactions:
               reply = processedTransactions[transaction]
               outcome, self.balance = reply.split('|') 
               #output("repeat")
               #resend the same reply when done with processing
            else:   
               #output(accountSummary)
               if int(accountNumber) in accountSummary:
                  balance = accountSummary[int(accountNumber)]
                  #output("getbalance: repeat123")
               else:
                  self.balance = 0.0
                  #accountSummary[int(accountNumber)] = self.balance  
                  outcome = 'Processed' 
                   
               #Add this transaction to the list of processed transactions
              #processedTransactions[transaction] = 'Processed' + "|"+str(self.balance)
            #only if process is tail
          
            #output("GetBalance processed ..sending to client, from: " + role)
            send((outcome,'GetBalance', bankName, clientNumber, sequenceNumber, accountNumber, balance,), to=client)
            sendCount +=1
            if(sendCount >= maxSend):
              crash = True
              output("\n\tWithdraw:server crashed just after sending req. no:" + str(sendCount))
            

    def receive(msg=('Deposit', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount), from_=client):
        
        self.clientId = clientId
        self.bankName = bankName
        self.clientNumber = clientNumber
        self.sequenceNumber = sequenceNumber
        self.accountNumber = accountNumber
        self.amount = amount
        self.reqType = 'Deposit'

        receiveCount +=1
        #output("\n\tcurrent receiveCount:" + str(receiveCount))
        if(sendCount >= maxSend or receiveCount >= maxReceive):
            crash = True
            if(sendCount >= maxSend):
              output("\n\tDeposit: server crashed just after sending req. no:" + str(sendCount))                
            else:
              output("\n\tDeposit : server crashed after receiving req. no:" + str(receiveCount))
        else:
          transaction = 'Deposit' + "|" + str(clientId)+ "|" + bankName + "|" + str(clientNumber)  + "|" + str(sequenceNumber)  + "|" + str(accountNumber) + "|" +  str(amount)
          reqID = str(clientNumber) + "|" + str(sequenceNumber) + "|" + str(accountNumber)          
          #If the same transaction has already been processed, return the same reply
          #print(clientId)
          if transaction in processedTransactions:
             reply = processedTransactions[transaction]
             #output(reply)
             outcome, balance = reply.split('|')
             if (role == 'tail'):
              output("Duplicate Deposit request...: " +role)
             
          elif reqID in processedRequestIDs:
             #Different transaction with same request ID. InconsistentWithHistory
             self.balance = accountSummary[int(accountNumber)]
             outcome = 'InconsistentWithHistory'
             output("InconsistentWithHistory")
          else:
             if int(accountNumber) in accountSummary:
                self.balance = accountSummary[int(accountNumber)]
                output("deposit to existing accno")
             else:
                self.balance = 0.0
             
             self.balance = self.balance + int(amount)
             accountSummary[int(accountNumber)] = self.balance
             processedTransactions[transaction] = 'Processed' + "|" + str(self.balance)
             processedRequestIDs.append(reqID)
             outcome = 'Processed'
         
          if (role == 'tail'):
             output("Deposit processed ..sending to client, from: " + role +" to client: "+ str(clientId))
             
             send((outcome,'Deposit', bankName, clientNumber, sequenceNumber, accountNumber, balance,), to=clientId)
             
             output("sending ack to remove old update: "+ str(reqID) + " from:" +str(role))
             Sent[reqID] = True
             #print("\n\t Request Buffer at tail:........................")
            
             send(('ack',reqID), to=prev)           
          else:
             #output("Deposit sent to next server from: " + role)
             send(('Deposit', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount,), to=next)
             #set this reqID False until ack received from Tail or next server... 
             Sent[reqID] = False 
          
          sendCount +=1
          if(sendCount >= maxSend):
            crash = True
            output("\n\tWithdraw:server crashed just after sending req. no:" + str(sendCount))
                
    def receive(msg=('Withdraw', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount), from_=client):
        
        self.clientId = clientId
        self.bankName = bankName
        self.clientNumber = clientNumber
        self.sequenceNumber = sequenceNumber
        self.accountNumber = accountNumber
        self.amount = amount
        
        self.reqType = 'Withdraw'
        
        receiveCount +=1
        #crash if exceeds
        #output("\n\tcurrent receiveCount:" + str(receiveCount))
        if(sendCount >= maxSend or receiveCount >= maxReceive):
            crash = True
            if(sendCount >= maxSend):
                output("\n\tWithdraw:server crashed just after sending req. no:" + str(sendCount))
            else:
              output("\n\tWithdraw:server crashed after receiving req. no:" + str(receiveCount))                
        else:
          
          transaction = 'Withdraw' + "|" + str(clientId)+ "|" + bankName + "|" + str(clientNumber) + "|" +  str(sequenceNumber) + "|" +  str(accountNumber) + "|" + str(amount)
          reqID = str(clientNumber)  + "|" + str(sequenceNumber) + "|" + str(accountNumber)
          #If the same transaction has already been processed, return the same reply
          #output("Withdraw processed124:" + str(processedRequestIDs)         
             
          if transaction in processedTransactions:
             reply = processedTransactions[transaction]
             outcome, balance = reply.split('|')
             if (role == 'tail'):
              output("Duplicate Withdraw request...")
             #resend the same reply when done with processing
          elif reqID in processedRequestIDs:
             #Different transaction with same request ID. InconsistentWithHistory
             self.balance = accountSummary[int(accountNumber)]
             outcome = 'InconsistentWithHistory'
             #output("Withdraw processed .outcome:" + outcome)         
             
          else:
             if int(accountNumber) in accountSummary:
                self.balance = accountSummary[int(accountNumber)]
                #output("Withdraw processed4321")    
             else:
                self.balance = 0.0

             if self.balance < int(amount):
                outcome = 'InsufficientFunds'             
             else:
                self.balance = self.balance - int(amount)
                outcome = 'Processed'

             accountSummary[int(accountNumber)] = self.balance
             processedTransactions[transaction] = 'Processed' + "|" + str(self.balance)
             processedRequestIDs.append(reqID)
             
          if (role == 'tail'):
             output("Withdraw request ..sending to client from: " + role)         
             send((outcome,'Withdraw', bankName, clientNumber, sequenceNumber, accountNumber, balance,), to=clientId)
             output("sending ack to remove old update: "+ str(reqID) + " from : " +str(role))
             Sent[reqID] = True 
             send(('ack',reqID), to=prev)
          else:
             #output("Withdraw request sent to next server from: " + role)
             send(('Withdraw', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount,), to=next)
             #set this reqID False until ack received from Tail or next server... 
             Sent[reqID] = False         
          
          sendCount +=1
          if(sendCount >= maxSend):
            crash = True
            output("\n\tWithdraw:server crashed just after sending req. no:" + str(sendCount))

    #///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   
    def receive(msg=('Transfer from', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount, destBankNo, destAccount), from_=client):
        self.clientId = clientId
        self.bankName = bankName
        self.clientNumber = clientNumber
        self.sequenceNumber = sequenceNumber
        self.accountNumber = accountNumber
        self.amount = amount
        self.destBankNo = destBankNo
        self.destAccount = destAccount
        self.reqType = 'Transfer'
        self.receiveCount += 1
        #crash if exceeds
        #output("\n\tcurrent receiveCount:" + str(receiveCount))
        dupReq = 0
        if(sendCount >= maxSend or receiveCount >= maxReceive):
            crash = True
            if(sendCount >= maxSend):
                output("\n\tTransfer from:server crashed just after sending req. no:" + str(sendCount))
            else:
              output("\n\tTransfer from:server crashed after receiving req. no:" + str(receiveCount))                
        else:
          
          transaction = 'Transfer from' + "|" + str(clientId)+ "|" + bankName + "|" + str(clientNumber) + "|" +  str(sequenceNumber) + "|" +  str(accountNumber) + "|" + str(amount) + "|" +str(destBankNo) + "|" + str(destAccount)
          reqID = str(clientNumber)  + "|" + str(sequenceNumber) + "|" + str(accountNumber)
          #If the same transaction has already been processed, return the same reply
          #output("Withdraw processed124:" + str(processedRequestIDs)         
             
          if transaction in processedTransactions:
             reply = processedTransactions[transaction]
             outcome, balance = reply.split('|')
             if (role == 'tail'):
                output("Duplicate Transfer request sending same reply...")
                dupReq = 1
             
          elif reqID in processedRequestIDs:
             #Different transaction with same request ID. InconsistentWithHistory
             self.balance = accountSummary[int(accountNumber)]
             outcome = 'InconsistentWithHistory'
             output("InconsistentWithHistory...")         
             
          else:
             if int(accountNumber) in accountSummary:
                self.balance = accountSummary[int(accountNumber)]
                #output("Withdraw processed4321")    
             else:
                self.balance = 0.0

             if self.balance < int(amount):
                outcome = 'InsufficientFunds'             
             else:
                self.balance = self.balance - int(amount)
                outcome = 'Processed'

             accountSummary[int(accountNumber)] = self.balance
             processedTransactions[transaction] = 'Processed' + "|" + str(self.balance)
             processedRequestIDs.append(reqID)
             
          if (role == 'tail'):
             if (outcome == 'InsufficientFunds') or (outcome == 'InconsistentWithHistory' or (dupReq == 1)):
                send((outcome,'Transfer', int(destBankNo), clientNumber, sequenceNumber, accountNumber, balance,), to=clientId)
                Sent[reqID] = True
                #print("\n\t Request Buffer at tail: ...............")
                send(('ack',reqID), to=prev)
             else:
                print (str(dupReq))
                output("Transfer to request ..sending to another bank head from: " + role)         
                send(('destBank ID',int(bankNo)+1,int(self.bankNo)), to=master)
                Sent[reqID] = False

          else:
             output("Transfer from request sent to next server from: " + role)
             send(('Transfer from', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount, destBankNo, destAccount), to=next)
             Sent[reqID] = False
          #set this reqID False until ack received from Tail or next server... 
                   
          sendCount +=1
          if(sendCount >= maxSend):
            crash = True
            output("\n\tTransfer from:server crashed just after sending req. no:" + str(sendCount)) 

    def receive(msg=('Transfer to', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount, destBankNo, destAccount), from_=sourceBank):
        self.clientId = clientId
        self.bankName = bankName
        self.clientNumber = clientNumber
        self.sequenceNumber = sequenceNumber
        self.accountNumber = accountNumber
        self.amount = amount
        self.destBankNo = destBankNo
        self.destAccount = destAccount

        
        self.reqType = 'Transfer'
        self.receiveCount +=1
        dupReq = False
        #crash if exceeds
        #output("\n\tcurrent receiveCount:" + str(receiveCount))
        if(sendCount >= maxSend or receiveCount >= maxReceive):
            crash = True
            if(sendCount >= maxSend):
                output("\n\tTransfer to:server crashed just after sending req. no:" + str(sendCount))
            else:
              output("\n\tTransfer to:server crashed after receiving req. no:" + str(receiveCount))                
        else:
          
          transaction = 'Transfer to' + "|" + str(clientId)+ "|" + bankName + "|" + str(clientNumber) + "|" +  str(sequenceNumber) + "|" +  str(accountNumber) + "|" + str(amount) + "|" +str(destBankNo) + "|" + str(destAccount)
          reqID = str(clientNumber)  + "|" + str(sequenceNumber) + "|" + str(accountNumber)
          #If the same transaction has already been processed, return the same reply
          #output("Withdraw processed124:" + str(processedRequestIDs)         
             
          if transaction in processedTransactions:
             reply = processedTransactions[transaction]
             outcome, balance = reply.split('|')
             if (role == 'tail'):
                dupReq = True
                output("Duplicate Transfer request sending same reply...")
                #resend the same reply when done with processing
          elif reqID in processedRequestIDs:
             #Different transaction with same request ID. InconsistentWithHistory
             self.balance = accountSummary[int(destAccount)]
             outcome = 'InconsistentWithHistory'
             #output("Withdraw processed .outcome:" + outcome)         
             
          else:
             if int(destAccount) in accountSummary:
                self.balance = accountSummary[int(destAccount)]
                #output("Withdraw processed4321")    
             else:
                self.balance = 0.0

             self.balance = self.balance + int(amount)
             outcome = 'Processed'

             accountSummary[int(destAccount)] = self.balance
             processedTransactions[transaction] = 'Processed' + "|" + str(self.balance)
             processedRequestIDs.append(reqID)
             
          if (role == 'tail'):
             output("Transfer to request ..sending to another bank head from: " + role)         
             send((outcome,'Transfer', int(bankNo)+1, clientNumber, sequenceNumber, accountNumber, balance,), to=clientId)
             #output("sending ack to remove old update: "+ str(reqID) + " from : " +str(role))
             Sent[reqID] = True
             #print("\n\t Request Buffer at tail: ...............")
             send(('ack',reqID), to=prev)
          else:
             output("Transfer to request sent to next server from: " + role)
             send(('Transfer to', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount, destBankNo, destAccount), to=next)
             #set this reqID False until ack received from Tail or next server... 
             Sent[reqID] = False  
             if role == 'head':
                send(('ack',reqID), to=sourceBank)

          
          sendCount +=1
          if(sendCount >= maxSend):
             crash = True
             output("\n\tTransfer to:server crashed just after sending req. no:" + str(sendCount)) 
     
    def receive(msg=('destBank id',destBank), from_=master):
        send(('Transfer to', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount, destBankNo, destAccount), to=destBank)
              

    #///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
class Client(process):
    def setup(head,tail,requestList,master):
        self.balance = 0.0
        self.requestType = None
        self.head =head
        self.tail =tail
        self.amount = 0
        self.outcome = None
        self.bankName = None
        self.clientNumber = 0
        self.sequenceNumber = 0
        self.accountNumber = 0
        self.destBank = -1
        self.destAccount = -1
        self.master = master

        

    def main():
        
        setup_logfile("./Logs/client_logs.txt")
        #output("Logging client logs to Logs/client_logs.txt")


        send(('Client init'), to=master)      #send to Master     
    
        for x in requestList:
          #output("request args:" + str(x[2]))
          requestType = x[0]
          bankName = x[1]
          
          t = x[2].split(',')
          clientNumber = t[0]
          sequenceNumber = t[1]
          accountNumber = t[2]
          
          if requestType == 'GetBalance': 
            send((requestType, self.id, bankName, clientNumber, sequenceNumber, accountNumber,), to=tail)         #directly send to server-tail
          elif requestType == 'Transfer':
            amount = t[3]
            destBank = t[4]
            destAccount = t[5]
            output("\n Client Sending " + str(requestType) + " request with clientNumber: " + str(clientNumber) + " and sequenceNumber: " + str(sequenceNumber))
            send(('Transfer from', self.id, bankName, clientNumber, sequenceNumber, accountNumber, amount,destBank,destAccount), to=head)      #send to server head
          else: 
            amount = t[3]
            #output("\n Client Sending " + str(requestType) + " request with clientNumber: " + str(clientNumber) + " and sequenceNumber: " + str(sequenceNumber))
            send((requestType, self.id, bankName, clientNumber, sequenceNumber, accountNumber, amount,), to=head)      #send to server head

        #await(some(received((outcome,requestType,bankName, clientNumber, sequenceNumber, accountNumber, balance,), )))
        await(False)
        #await(received((outcome,requestType,bankName, clientNumber, sequenceNumber, accountNumber, balance,),))
    
    def setup_logfile(filename):
        rootlog = logging.getLogger('')
        filelvl = logging.INFO
        fh = logging.FileHandler(filename)
        formatter = logging.Formatter('[%(asctime)s]%(name)s: %(message)s')
        fh.setFormatter(formatter)
        fh.setLevel(filelvl)
        rootlog._filelvl = filelvl
        rootlog.addHandler(fh)


    def receive(msg=(outcome,requestType,bankName, clientNumber, sequenceNumber, accountNumber, balance,)):
        if requestType == 'GetBalance':
           output("Request: " + str(requestType) + ", Outcome: " + outcome + ", Bank: " + str(bankName) + ", ClientNumber: " + str(clientNumber) + ", SequenceNumber: " + str(sequenceNumber) + ", AccountNumber: " + str(accountNumber) + ", Balance: " + str(balance))
        elif requestType == 'Transfer':
           output("Request: " + str(requestType) + ", Outcome: " + outcome + ", From Bank: " + str(bankName) + ", ClientNumber: " + str(clientNumber) + ", SequenceNumber: " + str(sequenceNumber) + ",From AccountNumber: " + str(accountNumber) + ", Updated Balance: " + str(balance))
        else:
           output("Request: " + str(requestType) + ", Outcome: " + outcome + ", Bank: " + str(bankName) + ", ClientNumber: " + str(clientNumber) + ", SequenceNumber: " + str(sequenceNumber) + ", AccountNumber: " + str(accountNumber) + ", Balance: " + str(balance))
    
    def receive(msg=(role,server), from_=master):
        if role == 'head' and self.head != server:
          output("Client: msg received from Master: head change to :" +str(server))
          self.head = server
        elif role == 'tail' and self.tail != server:
          output("Client: msg received from Master: tail changed to:" +str(server))
          self.tail = server
    
    def receive(msg=("hello"),from_=server):
        output("\n<<<<<<<<<<<<<<<<<<<DONE>>>>>>>>>>>>")
    
def main():

  parser = configparser.ConfigParser()
  
  parser.read('./config_phase4/config.ini')
  #Config.read("c:\\tomorrow.ini")
  configType = "config1"
  for sysarg in sys.argv[1:]:
    configType = sysarg
  fileName = parser.get('config_test', str(configType))
  parser.read('./config_phase4/' +str(fileName))
  
  bankCount = int(parser.get('config_test', 'numBank'))
  masterTimeout = int(parser.get('config_test', 'masterTimeout'))
  serverTimeout = int(parser.get('config_test', 'serverTimeout'))
  #Master Process setup and creation
  master = new(Master, num= 1)
  totalServList = []
  totalClientList = []  
  totalChainList  = []

  for bankNo in range(1,bankCount+1):
    bankname = parser.get('config_test', 'bank' + str(bankNo))
    print('bank name:'+ bankname)
    
    bankclients = int(parser.get('config_test', 'bank' + str(bankNo) + 'client'))
    bankservers = int(parser.get('config_test', 'bank' + str(bankNo) + 'servers'))
    #create servers and clients
    if(bankservers <=0):
      return
    servers = list(new(Server,num=bankservers)) 
    clients = list(new(Client,num=bankclients))   
    totalServList.append(servers)
    totalClientList.append(clients)

    bankreqType = parser.get('config_test', 'bank' + str(bankNo) + 'reqType')
    bankwaitTime = int(parser.get('config_test', 'bank' + str(bankNo) + 'waitTime'))
    bankretryCount = int(parser.get('config_test', 'bank' + str(bankNo) + 'retryCount'))
    initChain = int(parser.get('config_test', 'bank' + str(bankNo) + 'chainCount'))
    
    tail = servers[initChain-1]
    head = servers[0]
    chainList = []
    chainList = servers[0:initChain]
    totalChainList.append(chainList)
    #send(('Chain init',chainList), to=master)
   
    for serverNum, p in enumerate(servers):
      
      bankserverLimit = parser.get('config_test', 'bank' + str(bankNo) + 'server' + str(serverNum+1))
      limitList = bankserverLimit.split(';')
      #0 represents unbounded limit
      startDelay = 0
      maxReceive = 0
      maxReceive = 0

      for i in range(0,len(limitList)):
        limitType = limitList[i].split(":")
        operation = limitType[0]
        #print (operation)
        if operation == 'maxSend':
          maxSend = int(limitType[1])
        elif operation == 'maxReceive':
          maxReceive =    int(limitType[1])
        elif operation == 'startDelay':
          startDelay = int(limitType[1])
      
 
      if serverNum == (initChain-1):
        setup(p, ['tail',servers[serverNum - 1],None,maxReceive,maxSend,startDelay,master,serverTimeout,bankNo-1])    
      
      elif serverNum == 0:
        setup(p, ['head',None,servers[serverNum + 1], maxReceive,maxSend,startDelay,master,serverTimeout,bankNo-1])
      
      elif serverNum < initChain:
        setup(p, ['replica'+str(serverNum),servers[serverNum - 1],servers[serverNum+1],maxReceive,maxSend,startDelay,master,serverTimeout,bankNo-1])    
      else:
        setup(p, [None,None,None,maxReceive,maxSend,startDelay,master,serverTimeout,bankNo-1])    
        
    for i, p in enumerate(clients):
      requestList = []
      if bankreqType == 'itemized':
        bankitemisedReq = parser.get('config_test', 'bank' + str(bankNo) + 'client' + str(i+1) + 'itemisedReq')
        reqlist = bankitemisedReq.split(';')
        print("no of requests: " + str(len(reqlist)) + "--from bank" + str(bankNo)+ "client"+str(i+1))
        for m in range (0,len(reqlist)):
          reqtype=reqlist[m].split(":")
          operation = reqtype[0]
          reqargs = reqtype[1].split(",")
          #reqargs.append(str(bankwaitTime))
          #reqargs.append(str(bankretryCount))
          if operation == 'getBalance':
            #print(reqargs)
            reqarg =  ",".join(reqargs)
            requestList.append(('GetBalance', bankname,reqarg))

          elif operation == 'Deposit':
            reqarg =  ",".join(reqargs)
            requestList.append(('Deposit', bankname,reqarg))
          
          elif operation == 'Withdraw':
            reqarg =  ",".join(reqargs)
            requestList.append(('Withdraw', bankname,reqarg))
          
          elif operation == 'Transfer':
            reqarg =  ",".join(reqargs)
            requestList.append(('Transfer', bankname,reqarg))

        #outside of for loop
        #print (requestList[0])
        setup(p, (head,tail,requestList,master))
      else :

        #output("random query.....")
        probGetBalance = float(parser.get('config_test', 'bank' + str(bankNo) + 'probGetBalance'))
        probDeposit = float(parser.get('config_test', 'bank' + str(bankNo) + 'probDeposit')) 
        probWithdraw = float(parser.get('config_test', 'bank' + str(bankNo) + 'probWithdraw'))
        requestCount = (random.randint(1, 100000))%10
        print("no of auto requests: " + str(requestCount+1))
        
        accno = random.randint(1, 1000) 
        clientno = random.randint(1, 1000) 
        

        for c in range(0,requestCount+1):
          select = random.randint(1, 100000)%10 + 1
          amt = random.randint(1, 1000) 
          seqno = c+1
          reqlist = []
          reqlist.append(str(clientno))
          reqlist.append(str(seqno))
          reqlist.append(str(accno))
          reqlist.append(str(amt))
          reqarg =  ",".join(reqlist)
          if select < probGetBalance*10 : 
            requestList.append(('getBalance',bankname,reqarg))
          
          elif select < probDeposit*10:
            requestList.append(('Withdraw',bankname,reqarg))
          
          else:
            requestList.append(('Deposit',bankname,reqarg))
        setup(p, (head,tail,requestList,master))
      #end of client loop
    #end of server loop
  #end of bank loop

  setup(master,[totalChainList,totalClientList,masterTimeout])
  start(master)
  for bankNo in range(bankCount):
    #print(totalServList[t])
    start(totalServList[bankNo])
    start(totalClientList[bankNo])
  