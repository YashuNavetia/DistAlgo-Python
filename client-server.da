import sys
import configparser
import logging
import random
#import set
#import time
#import re
TIMEOUT = 1
def setup_logfile(filename):
        rootlog = logging.getLogger('')
        filelvl = logging.INFO
        fh = logging.FileHandler(filename)
        formatter = logging.Formatter('[%(asctime)s]%(name)s: %(message)s')
        fh.setFormatter(formatter)
        fh.setLevel(filelvl)
        rootlog._filelvl = filelvl

class Master(process):
    def setup(chainList):
        self.q = set()
        self.servList = list(chainList)
        #self.myself = master
        self.removeIndex = []
        self.clientList = []
        self.tail = chainList[len(chainList)-1]
        self.crashTail = tail
        self.newTail = tail
        self.flag = 1
   
    def notify():
      
      while True:
        
        if (await(False)):
          pass
        elif timeout(5*TIMEOUT):
          
          if not servList:
            break
          serverCrash = False
          tail = servList[len(servList) - 1]

          for i,server in enumerate(servList):   
            if((0,server) in q):
              q.remove((0,server))
            else:
              removeIndex.append(server)
              serverCrash = True
              output("\nMaster:identified crashed server now as: " +str(server))
              
          if (serverCrash):
            for value in removeIndex:
                servList.remove(value)
            
            chainLength = len(servList)
            head = servList[0]
            self.tail = servList[chainLength - 1]
            if chainLength >1:
              for i,server in enumerate(servList):            
                #output("STOP under TESTING")
                                
                if(server == head):
                  prev = None
                  next = servList[i+1]
                  role = 'head'
                  send(('Update',None,next,role), to=server)
                  send((role,server), to=clientList)
                elif (server == tail):
                  prev = servList[i-1]
                  next = None
                  role = 'tail'
                  send(('Update',prev,None,role), to=server)
                  send((role,server), to=clientList)
                else:
                  role = 'replica'+str(i)
                  output(role)
                  prev = servList[i-1]
                  next = servList[i+1]
                  send(('Update',prev,next,role), to=server)

                #output("\n\tSending req. to update buffer\n")
                #send(('start updating buffer'), to=head)
            
            del removeIndex[:]   

          
    # Add in queue for all server pings- "I am Alive"
    def receive(msg=('I am alive'), from_=server):
        output("\n\tI am alive-server: " +str(server)+"\n")
        q.add((0,server))
        if(crashTail != tail):
          if(flag ==0):
            output("removed crash tail,now temp tail: "+str(tail))
            role = 'replica'+str(len(servList)-1)
            send(('chainUpdate',role,newTail), to=tail)
            flag = 1
        

    def receive(msg=('Client init'), from_=client):
        clientList.append(client)
        #output("Master: init msg received from client: "+str(client))

    def receive(msg=('chainExtention'), from_=newTail):
        output("chain Extension msg received from server new"+str(newTail))
        role = 'replica'+str(len(servList)-1)
        output("current tail"+str(tail))
        crashTail = tail
        self.newTail = newTail
        flag =0
        #if await(False):pass
        #elif timeout(6*TIMEOUT):
        #if(crashTail != tail):
        send(('chainUpdate',role,newTail), to=tail)
        
    def receive(msg=('newTail'),from_=newTail):
        output("chain Extension completes,new tail added:"+str(newTail))
        servList.append(newTail) 
        tail = newTail
        crashTail = tail
        send(('tail',newTail), to=clientList)

    def receive(msg=('sync next',tempList,sendTo),from_=server):
        output("sync next received from:" +str(server))
        #output(tempList)
        reqType = tempList[0]
        clientId = str(tempList[1])
        for client in clientList:
          if clientId in (str(client)):
            clientId = clientList[0]
            break       
        bankName = tempList[2]
        clientNumber = tempList[3]
        sequenceNumber = tempList[4]
        accountNumber = tempList[5]
        amount = tempList[6]
        send((reqType, clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount,), to=sendTo)
        #output("\n\tclientid:" + str(clientId))
        
             
    
    def main():
        #if(len(servList) >0):
        notify()
        await(0)

    
class Server(process):
    #self.next1 = 5
    def setup(role,prev,next,maxReceive,maxSend,startDelay,master):  
        self.bankName = None
        self.clientNumber = -1
        self.sequenceNumber = -1
        self.accountNumber = -1   
        self.amount = 0.0
        self.outcome = None
        self.processedTransactions = {}
        #The below list stores the request IDs that have been processed
        self.processedRequestIDs = list()
        #The below dictionary stores the account numbers and the balance in the account
        self.accountSummary = {}
        self.balance = 0.0   #need to change
        self.maxReceive = maxReceive
        self.maxSend = maxSend
        self.startDelay = startDelay
        self.role = str(role)
        self.master = master
        self.crash = False
        self.prev = prev
        self.next = next
        self.receiveCount = 0
        self.sendCount = 0
        self.reqType = None
        self.clientId = None
        self.Sent = {}
        #self.sleep = True        

        #output("start Server id:" + str(self.id)+ " next id " +str(next))

    def main():   
        
        while(startDelay):
          if await(False):
            pass
          elif timeout(startDelay):
            startDelay = 0
            send(('chainExtention'), to=master)
                      
        while (crash == False):
          #output("inside main, server: "+ str(role) +str(crash))
          if(receiveCount >= maxReceive or sendCount >= maxSend):
            crash = True        
          if(await(False)):
            pass
          elif timeout(TIMEOUT):
            send(('I am alive'), to=master)
            
        #output("Killing server: with crash value" + str(crash))
        await(crash)

    def receive(msg=('ack',reqID), from_=next):
        if(crash != True):
          Sent[reqID] = True;
          #output("sending ack to remove old update: "+ str(reqID) + " from : " +str(role))
          if prev != None:
            send(('ack',reqID), to=prev)


    def sync_next(reqID):
        if(crash != True):
          output("\n inside sync_next:" + reqID+"\n")
          #'Deposit' + str(clientId) + bankName + reqID + str(amount)
            
          for transaction in processedTransactions:
            if reqID in transaction.lower():
              print(str(transaction))
              tempList = transaction.split("|")
              break;
          sendTo = next
          if(next == None):
            sendTo = self.id
          #output("<<<<<<<check here...........sending to: "+ str(sendTo))
          #print(str(type(sendTo)) + "value:" + str(sendTo))
          send(("sync next",tempList,sendTo), to=master)
          

    def receive(msg=('Update',prevServ, nextServ,role), from_=master):
        #output("<<<<<<<check here............>>>>>>"+str(prevServ)+ "next: "+str(nextServ))
        if(crash != True):
          if (next != nextServ):
            next = nextServ
            self.role = str(role)
            #output("<<<<<<<check here............>>>>>>"+str(role))
            for reqID in Sent.keys():
              if Sent[reqID] == False:
                sync_next(reqID)
          prev = prevServ
        

                      
   
    def receive(msg=('chainUpdate',newRole,newTail), from_=master):
        if(crash != True):
          role = newRole
          next = newTail
          send(('setup',processedTransactions,processedRequestIDs,accountSummary,Sent),to=newTail)
     

    def receive(msg=('setup',processedTransactions,processedRequestIDs,accountSummary,Sent),from_=prevTail):
        output("i am new tail,informing master")
        if(crash != True):
          role = 'tail'
          next = None
          prev = prevTail
          self.processedTransactions = processedTransactions
          self.processedRequestIDs = processedRequestIDs
          self.accountSummary = accountSummary
          self.Sent = dict(Sent)
          send(('newTail'),to=master)
                  
    #///////////////////////////////////////////////////////QUERY HANDLING FROM CLIENT////////////////////////////////////////////////////////////////////////

    def receive(msg=('GetBalance', clientId, bankName, clientNumber, sequenceNumber, accountNumber), from_=client):
        #output("\nreq. received for getbalance,my role: "+str(role))
        #output(str(role))
        if role == 'tail':
          #output("\nreq. received for getbalance...\n")
          self.clientId = clientId
          self.bankName = bankName
          self.clientNumber = clientNumber
          self.sequenceNumber = sequenceNumber
          self.accountNumber = accountNumber
          
          self.receiveCount +=1
          self.reqType = 'GetBalance'
          
          #output("\role: "+str(role)+",receive: "+str(maxReceive))
          if(sendCount >= maxSend or receiveCount >= maxReceive):
            crash = True
            if(sendCount >= maxReceive):
              output("\n\tGet balance:server crashed just after sending total req no:" + str(sendCount))
            else:
              output("\n\tGet balance:server crashed after receiving total req = " + str(receiveCount))
          else:
            transaction = 'GetBalance' + str(clientId)+bankName + str(clientNumber) + str(sequenceNumber) + str(accountNumber)
            #If the same transaction has already been processed, return the same reply
            if transaction in processedTransactions:
               reply = processedTransactions[transaction]
               outcome, self.balance = reply.split('|') 
               #output("repeat")
               #resend the same reply when done with processing
            else:   
               #output(accountSummary)
               if int(accountNumber) in accountSummary:
                  balance = accountSummary[int(accountNumber)]
                  #output("getbalance: repeat123")
               else:
                  self.balance = 0.0
                  #accountSummary[int(accountNumber)] = self.balance  
                  outcome = 'Processed' 
                   
               #Add this transaction to the list of processed transactions
              #processedTransactions[transaction] = 'Processed' + "|"+str(self.balance)
            #only if process is tail
          
            #output("GetBalance processed ..sending to client, from: " + role)
            send((outcome,'GetBalance', bankName, clientNumber, sequenceNumber, accountNumber, balance,), to=client)
            sendCount +=1
            if(sendCount >= maxSend):
              crash = True
              output("\n\tWithdraw:server crashed just after sending req. no:" + str(sendCount))
            

    def receive(msg=('Deposit', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount), from_=client):
        
        self.clientId = clientId
        self.bankName = bankName
        self.clientNumber = clientNumber
        self.sequenceNumber = sequenceNumber
        self.accountNumber = accountNumber
        self.amount = amount
        self.reqType = 'Deposit'

        self.receiveCount +=1
        #output("\n\tcurrent receiveCount:" + str(receiveCount))
        if(sendCount >= maxSend or receiveCount >= maxReceive):
            crash = True
            if(sendCount >= maxSend):
              output("\n\tDeposit: server crashed just after sending req. no:" + str(sendCount))                
            else:
              output("\n\tDeposit : server crashed after receiving req. no:" + str(receiveCount))
        else:
          transaction = 'Deposit' + "|" + str(clientId)+ "|" + bankName + "|" + str(clientNumber)  + "|" + str(sequenceNumber)  + "|" + str(accountNumber) + "|" +  str(amount)
          reqID = str(clientNumber) + "|" + str(sequenceNumber) + "|" + str(accountNumber)          
          #If the same transaction has already been processed, return the same reply
          print(clientId)
          if transaction in processedTransactions:
             reply = processedTransactions[transaction]
             #output(reply)
             outcome, balance = reply.split('|')
             if (role == 'tail'):
              output("Duplicate Deposit request...: " +role)
             
          elif reqID in processedRequestIDs:
             #Different transaction with same request ID. InconsistentWithHistory
             self.balance = accountSummary[int(accountNumber)]
             outcome = 'InconsistentWithHistory'
             output("InconsistentWithHistory")
          else:
             if int(accountNumber) in accountSummary:
                self.balance = accountSummary[int(accountNumber)]
                output("deposit to existing accno")
             else:
                self.balance = 0.0
             
             self.balance = self.balance + int(amount)
             accountSummary[int(accountNumber)] = self.balance
             processedTransactions[transaction] = 'Processed' + "|" + str(self.balance)
             processedRequestIDs.append(reqID)
             outcome = 'Processed'
         
          if (role == 'tail'):
             output("Deposit processed ..sending to client, from: " + role +" to client: "+ str(clientId))
             
             send((outcome,'Deposit', bankName, clientNumber, sequenceNumber, accountNumber, balance,), to=clientId)
             
             #output("sending ack to remove old update: "+ str(reqID) + " from:" +str(role))
             Sent[reqID] = True
             print("\n\t Request Buffer at tail:........................")
             for key,value in Sent.items():
               print (key) 
               print (value) 
             send(('ack',reqID), to=prev)           
          else:
             #output("Deposit sent to next server from: " + role)
             send(('Deposit', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount,), to=next)
             #set this reqID False until ack received from Tail or next server... 
             Sent[reqID] = False 
          
          sendCount +=1
          if(sendCount >= maxSend):
            crash = True
            output("\n\tWithdraw:server crashed just after sending req. no:" + str(sendCount))
                
    def receive(msg=('Withdraw', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount), from_=client):
        
        self.clientId = clientId
        self.bankName = bankName
        self.clientNumber = clientNumber
        self.sequenceNumber = sequenceNumber
        self.accountNumber = accountNumber
        self.amount = amount
        
        self.reqType = 'Withdraw'
        self.receiveCount +=1
        #crash if exceeds
        #output("\n\tcurrent receiveCount:" + str(receiveCount))
        if(sendCount >= maxSend or receiveCount >= maxReceive):
            crash = True
            if(sendCount >= maxSend):
                output("\n\tWithdraw:server crashed just after sending req. no:" + str(sendCount))
            else:
              output("\n\tWithdraw:server crashed after receiving req. no:" + str(receiveCount))                
        else:
          
          transaction = 'Withdraw' + "|" + str(clientId)+ "|" + bankName + "|" + str(clientNumber) + "|" +  str(sequenceNumber) + "|" +  str(accountNumber) + "|" + str(amount)
          reqID = str(clientNumber)  + "|" + str(sequenceNumber) + "|" + str(accountNumber)
          #If the same transaction has already been processed, return the same reply
          #output("Withdraw processed124:" + str(processedRequestIDs)         
             
          if transaction in processedTransactions:
             reply = processedTransactions[transaction]
             outcome, balance = reply.split('|')
             if (role == 'tail'):
              output("Duplicate Withdraw request...")
             #resend the same reply when done with processing
          elif reqID in processedRequestIDs:
             #Different transaction with same request ID. InconsistentWithHistory
             self.balance = accountSummary[int(accountNumber)]
             outcome = 'InconsistentWithHistory'
             #output("Withdraw processed .outcome:" + outcome)         
             
          else:
             if int(accountNumber) in accountSummary:
                self.balance = accountSummary[int(accountNumber)]
                #output("Withdraw processed4321")    
             else:
                self.balance = 0.0

             if self.balance < int(amount):
                outcome = 'InsufficientFunds'             
             else:
                self.balance = self.balance - int(amount)
                outcome = 'Processed'

             accountSummary[int(accountNumber)] = self.balance
             processedTransactions[transaction] = 'Processed' + "|" + str(self.balance)
             processedRequestIDs.append(reqID)
             
          if (role == 'tail'):
             output("Withdraw request ..sending to client from: " + role)         
             send((outcome,'Withdraw', bankName, clientNumber, sequenceNumber, accountNumber, balance,), to=clientId)
             #output("sending ack to remove old update: "+ str(reqID) + " from : " +str(role))
             Sent[reqID] = True 
             print("\n\t Request Buffer at tail: ...............")
             for key,value in Sent.items():
               print (key) 
               print (value)
             send(('ack',reqID), to=prev)
          else:
             #output("Withdraw request sent to next server from: " + role)
             send(('Withdraw', clientId, bankName, clientNumber, sequenceNumber, accountNumber, amount,), to=next)
             #set this reqID False until ack received from Tail or next server... 
             Sent[reqID] = False         
          
          sendCount +=1
          if(sendCount >= maxSend):
            crash = True
            output("\n\tWithdraw:server crashed just after sending req. no:" + str(sendCount))
      
class Client(process):
    def setup(head,tail,requestList,master):
        self.balance = 0.0
        self.requestType = None
        self.head =head
        self.tail =tail
        self.amount = 0
        self.outcome = None
        self.bankName = None
        self.clientNumber = 0
        self.sequenceNumber = 0
        self.accountNumber = 0
        self.master = master

        

    def main():
        #parse requestList here...
        
        #parsereqList(reqList)
        send(('Client init'), to=master)      #send to Master     
    
        for x in requestList:
          #output("request args:" + str(x[2]))
          requestType = x[0]
          bankName = x[1]
          
          t = x[2].split(',')
          clientNumber = t[0]
          sequenceNumber = t[1]
          accountNumber = t[2]
          
          if requestType == 'GetBalance': 
            #output("GetBalance.."+x[2])
            #output("\n Client Sending " + str(requestType) + " request with clientNumber: " + str(clientNumber) + " and sequenceNumber: " + str(sequenceNumber))
            send((requestType, self.id, bankName, clientNumber, sequenceNumber, accountNumber,), to=tail)         #directly send to server-tail
          else: 
            #output("else.."+x[2])
            amount = t[3]
            #output("\n Client Sending " + str(requestType) + " request with clientNumber: " + str(clientNumber) + " and sequenceNumber: " + str(sequenceNumber))
            send((requestType, self.id, bankName, clientNumber, sequenceNumber, accountNumber, amount,), to=head)      #send to server head

        #await(some(received((outcome,requestType,bankName, clientNumber, sequenceNumber, accountNumber, balance,), )))
        await(False)
        #await(received((outcome,requestType,bankName, clientNumber, sequenceNumber, accountNumber, balance,),))
    
    def receive(msg=(outcome,requestType,bankName, clientNumber, sequenceNumber, accountNumber, balance,)):
        if requestType == 'GetBalance':
           output("Request: " + str(requestType) + ", Outcome: " + outcome + ", Bank: " + bankName + ", ClientNumber: " + str(clientNumber) + ", SequenceNumber: " + str(sequenceNumber) + ", AccountNumber: " + str(accountNumber) + ", Balance: " + str(balance))
        else:
           output("Request: " + str(requestType) + ", Outcome: " + outcome + ", Bank: " + bankName + ", ClientNumber: " + str(clientNumber) + ", SequenceNumber: " + str(sequenceNumber) + ", AccountNumber: " + str(accountNumber) + ", Balance: " + str(balance))
    
    def receive(msg=(role,server), from_=master):
        if role == 'head' and self.head != server:
          output("Client: msg received from Master: head change to :" +str(server))
          self.head = server
        elif role == 'tail' and self.tail != server:
          output("Client: msg received from Master: tail changed to:" +str(server))
          self.tail = server
    
    def receive(msg=("hello"),from_=server):
        output("\n<<<<<<<<<<<<<<<<<<<DONE>>>>>>>>>>>>")
    
def main():

  parser = configparser.ConfigParser()
  parser.read('config1.ini')
  #Config.read("c:\\tomorrow.ini")
  bankCount = int(parser.get('config_test', 'numBank'))
  #Master Process setup and creation
  master = new(Master, num= 1)
    

  for t in range(1,bankCount+1):
    bankname = parser.get('config_test', 'bank' + str(t))
    print('bank name:'+ bankname)
    
    bankclients = int(parser.get('config_test', 'bank' + str(t) + 'client'))
    bankservers = int(parser.get('config_test', 'bank' + str(t) + 'servers'))
    #create servers and clients
    if(bankservers <=0):
      return
    servers = list(new(Server,num=bankservers)) 
    clients = list(new(Client,num=bankclients))   
    
    bankreqType = parser.get('config_test', 'bank' + str(t) + 'reqType')
    bankwaitTime = int(parser.get('config_test', 'bank' + str(t) + 'waitTime'))
    bankretryCount = int(parser.get('config_test', 'bank' + str(t) + 'retryCount'))
    initChain = int(parser.get('config_test', 'bank' + str(t) + 'chainCount'))
    
    tail = servers[initChain-1]
    head = servers[0]
    chainList = []
    chainList = servers[0:initChain]
    #send(('Chain init',chainList), to=master)
    setup(master,[chainList])
    start(master)
    for serverNum, p in enumerate(servers):
      
      bankserverLimit = parser.get('config_test', 'bank' + str(t) + 'server' + str(serverNum+1))
      limitList = bankserverLimit.split(';')
      #0 represents unbounded limit
      startDelay = 0
      maxReceive = 0
      maxReceive = 0

      for i in range(0,len(limitList)):
        limitType = limitList[i].split(":")
        operation = limitType[0]
        #print (operation)
        if operation == 'maxSend':
          maxSend = int(limitType[1])
        elif operation == 'maxReceive':
          maxReceive =    int(limitType[1])
        elif operation == 'startDelay':
          startDelay = int(limitType[1])
      #print(str(initChain))
 
      if serverNum == (initChain-1):
        setup(p, ['tail',servers[serverNum - 1],None,maxReceive,maxSend,startDelay,master])    
      
      elif serverNum == 0:
        setup(p, ['head',None,servers[serverNum + 1], maxReceive,maxSend,startDelay,master])
      
      elif serverNum < initChain:
        setup(p, ['replica'+str(serverNum),servers[serverNum - 1],servers[serverNum+1],maxReceive,maxSend,startDelay,master])    
      else:
        setup(p, [None,None,None,maxReceive,maxSend,startDelay,master])    
        
    for i, p in enumerate(clients):
      requestList = []
      if bankreqType == 'itemized':
        bankitemisedReq = parser.get('config_test', 'bank' + str(t) + 'client' + str(i+1) + 'itemisedReq')
        reqlist = bankitemisedReq.split(';')
        print("no of requests: " + str(len(reqlist)) + "--from client" + str(i+1))
        for m in range (0,len(reqlist)):
          reqtype=reqlist[m].split(":")
          operation = reqtype[0]
          reqargs = reqtype[1].split(",")
          #reqargs.append(str(bankwaitTime))
          #reqargs.append(str(bankretryCount))
          if operation == 'getBalance':
            #print(reqargs)
            reqarg =  ",".join(reqargs)
            requestList.append(('GetBalance', bankname,reqarg))

          if operation == 'Deposit':
            reqarg =  ",".join(reqargs)
            requestList.append(('Deposit', bankname,reqarg))
          if operation == 'Withdraw':
            reqarg =  ",".join(reqargs)
            requestList.append(('Withdraw', bankname,reqarg))
        #outside of for loop
        #print (requestList[0])
        setup(p, (head,tail,requestList,master))
      else :

        #output("random query.....")
        probGetBalance = float(parser.get('config_test', 'bank' + str(t) + 'probGetBalance'))
        probDeposit = float(parser.get('config_test', 'bank' + str(t) + 'probDeposit')) 
        probWithdraw = float(parser.get('config_test', 'bank' + str(t) + 'probWithdraw'))
        requestCount = (random.randint(1, 100000))%10
        print("no of auto requests: " + str(requestCount+1))
        
        accno = random.randint(1, 1000) 
        clientno = random.randint(1, 1000) 
        

        for c in range(0,requestCount+1):
          select = random.randint(1, 100000)%10 + 1
          amt = random.randint(1, 1000) 
          seqno = c+1
          reqlist = []
          reqlist.append(str(clientno))
          reqlist.append(str(seqno))
          reqlist.append(str(accno))
          reqlist.append(str(amt))
          reqarg =  ",".join(reqlist)
          if select < probGetBalance*10 : 
            requestList.append(('getBalance',bankname,reqarg))
          
          elif select < probDeposit*10:
            requestList.append(('Withdraw',bankname,reqarg))
          
          else:
            requestList.append(('Deposit',bankname,reqarg))
                
        setup(p, (head,tail,requestList,master))
    
    start(servers)
    start(clients)
